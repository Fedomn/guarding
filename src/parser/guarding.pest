// online parser: [https://pest.rs/](https://pest.rs/)
start = _{ SOI ~ declaration* ~ EOI}

identifier = @{ (ASCII_ALPHA | ASCII_ALPHANUMERIC | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

declaration = {
  normal_rule |
  layer_rule
}

// module is a container of package
// package is a container of file and classes
// file is a container of classes and functions
// classes is a container of functions and field
normal_rule = {
	rule_level ~ ("(" ~ scope ~ ")")? ~ (prop ~ expression)? ~ should? ~ operation ~ assert ~ ";"?
}

rule_level = {
    "module" |
    "package" |
    "class" |
    "function" |
    "file"
}

layer_rule = {
	"layer" ~ "(" ~ layer_type ~ ")" ~ (prop ~ layer_expression)* ~ ";"?
}

// use property
prop = {
    "::" |
    "->"
}

layer_type = {
    string
}

layer_expression = {
    identifier ~ "(" ~ string ~ (comma ~ string)* ~ ")"
}

scope = {
    string |
    impl_scope |
    extend_scope |
    assignable_scope |
    match_scope
}

match_scope = {
    "match" ~ "(" ~ string ~ ")"
}
assignable_scope = {
    "assignable" ~ string
}
extend_scope = {
    "extends" ~ string
}

impl_scope = {
    "implementation" ~ string
}

expression = {
    fn_call
}

fn_call = {
    identifier ~ (dot ~ identifier )*
}

assert = {
    "(" ~ string ~ ")" |
    rule_level ~ "(" ~ string ~ ")" |
    string |
    int
}

operation = {
    "not" ~ operation |
    "!" ~ operation |
    "<=" |
    "<" |
    ">" |
    ">=" |
    "==" |
	"contains" |
	"endsWith" |
	"startsWith" |
	"resideIn" |
	"accessed" |
	"dependBy"
}

should = {
    "should"
}

double_quoted_string  = @{ "\"" ~ (!("\"") ~ ANY)* ~ "\""}
single_quoted_string  = @{ "\'" ~ (!("\'") ~ ANY)* ~ "\'"}

string = @{
    double_quoted_string |
    single_quoted_string
}

number = @{ '0'..'9'+ }
int = @{ number | "-" ~ "0"* ~ '1'..'9' ~ number? }

dot                 = { "." }
comma               = { "," }
semicolon           = { ";" }
opening_paren       = { "(" }
closing_paren       = { ")" }

newline    = _{ "\n" | "\r\n" }
WHITESPACE = _{ " " | "\t" | newline }

block_comment = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }
COMMENT    = _{ block_comment | ("//" ~ (!newline ~ ANY)*) }
