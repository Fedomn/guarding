start = _{ SOI ~ declarations* ~ EOI}

identifier = @{ (ASCII_ALPHA | ASCII_ALPHANUMERIC | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

declarations = {
  container_rule |
  layer_rule
}

// module is a container of package
// package is a container of file and classes
// file is a container of classes and functions
// classes is a container of functions and field
container_rule = {
	container ~ ("(" ~ scope ~ ")")? ~ ("::" ~ expression)? ~ should? ~ operation ~ assert ~ ";"?
}

container = {
    "module" |
    "package" |
    "class" |
    "function" |
    "file"
}

layer_rule = {
	"layer" ~ "(" ~ layer_type ~ ")" ~ ("::" ~ layer_expression)* ~ ";"?
}

layer_type = {
    string
}

layer_expression = {
    identifier ~ "(" ~ string ~ ("," ~ string)* ~ ")"
}

scope = {
    string |
    impl_scope |
    extend_scope |
    assignable_scope |
    match_scope
}

match_scope = {
    "match" ~ "(" ~ string ~ ")"
}
assignable_scope = {
    "assignable" ~ string
}
extend_scope = {
    "extends" ~ string
}

impl_scope = {
    "implementation" ~ string
}

expression = {
    identifier ~ (dot ~ identifier )*
}

assert = {
    opening_paren ~ string ~ closing_paren |
    container ~ opening_paren ~ string ~ closing_paren |
    string |
    int
}

operation = {
    "not" ~ operation |
    "!" ~ operation |
    "<=" |
    "<" |
    ">" |
    ">=" |
    "==" |
	"contains" |
	"endsWith" |
	"startsWith" |
	"resideIn" |
	"accessed" |
	"dependBy"
}

should = {
    "should"
}

double_quoted_string  = @{ "\"" ~ (!("\"") ~ ANY)* ~ "\""}
single_quoted_string  = @{ "\'" ~ (!("\'") ~ ANY)* ~ "\'"}
backquoted_quoted_string  = @{ "`" ~ (!("`") ~ ANY)* ~ "`"}

string = @{
    double_quoted_string |
    single_quoted_string |
    backquoted_quoted_string
}

number = @{ '0'..'9'+ }
int = @{ number | "-" ~ "0"* ~ '1'..'9' ~ number? }

dot                 = { "." }
opening_paren       = { "(" }
closing_paren       = { ")" }

newline    = _{ "\n" | "\r\n" }
WHITESPACE = _{ " " | "\t" | newline }
block_comment = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }
COMMENT    = _{ block_comment | ("//" ~ (!newline ~ ANY)*) }
